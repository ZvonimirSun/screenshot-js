import domToImage from 'dom-to-image'
import './screenshot.scss'

export default class ScreenShot {
  static getImage ({ node, width, height, callback = () => {} }) {
    return new Promise((resolve, reject) => {
      if (!(node instanceof window.HTMLElement)) {
        reject(new Error('node must be HTMLElement'))
      }
      let scale
      if (width && height) {
        scale = Math.min(node.offsetWidth / width, node.offsetHeight / height)
      } else {
        scale = 1
      }
      const style = {
        transform: 'scale(' + scale + ')',
        transformOrigin: 'top left',
        width: node.offsetWidth + 'px',
        height: node.offsetHeight + 'px'
      }
      const param = {
        height: node.offsetHeight * scale,
        width: node.offsetWidth * scale,
        quality: 1,
        style
      }
      domToImage
        .toBlob(node, param)
        .then((val) => {
          callback(val)
          resolve(val)
        })
        .catch((err) => {
          reject(err)
        })
    })
  }

  static getMergeImage ({ imgList = [], width, height, callback = () => {} }) {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas')
      canvas.width = width
      canvas.height = height
      const context = canvas.getContext('2d')

      let flag = 0
      imgList.forEach((item) => {
        if (item.img instanceof window.HTMLImageElement) {
          context.drawImage(item.img, 0, 0, item.width, item.height)
          flag++
        } else if (typeof item.img === 'string') {
          const img = new window.Image()
          img.src = item.img
          img.onload = () => {
            context.drawImage(
              img,
              item.x || 0,
              item.y || 0,
              item.width,
              item.height
            )
            flag++
            if (flag === imgList.length) {
              const data = canvas.toDataURL()
              callback(data)
              resolve(data)
            }
          }
          img.onerror = () => {
            flag++
            if (flag === imgList.length) {
              const data = canvas.toDataURL()
              callback(data)
              resolve(data)
            }
          }
        }
      })
      if (flag === imgList.length) {
        const data = canvas.toDataURL()
        callback(data)
        resolve(data)
      }
    })
  }

  constructor ({ node, img } = {}) {
    if (!(node instanceof window.HTMLElement)) {
      throw new Error('node must be HTMLElement')
    }
    if (node.__SCREEN_SHOT_GENERATED__) {
      throw new Error('node has been generated by ScreenShot')
    }

    this._initDom({ node, img })
    this._initSnipperEvent()
  }

  destroy (callback = () => {}) {
    _clearDom(this._node)
    delete this._node.__SCREEN_SHOT_GENERATED__
    delete this._node
    delete this._container
    delete this._img
    delete this._snipper
    delete this._resizer
    delete this._snipInfo
    delete this._drawer
    callback()
  }

  _initDom ({ node, img }) {
    this._initNode(node)
    this._initImage(img)
    this._initSnipper()
  }

  _initNode (node) {
    this._node = node
    this._node.__SCREEN_SHOT_GENERATED__ = true
    _clearDom(this._node)
    this._container = document.createElement('div')
    this._container.classList.add('screenshot')
    this._node.append(this._container)
  }

  _initImage (img) {
    if (img instanceof window.HTMLImageElement) {
      this._img = img
    } else if (typeof img === 'string') {
      this._img = new window.Image()
      this._img.src = img
    } else {
      return
    }
    this._img.classList.add('screenshot-image')
    this._container.append(this._img)
  }

  _initSnipper () {
    this._snipper = document.createElement('div')
    this._snipper.classList.add('screenshot-snipper')
    const nodeStyle = window.getComputedStyle(this._container)
    const snipperBorderWidth = Math.max(
      parseFloat(nodeStyle.width),
      parseFloat(nodeStyle.height)
    )
    this._snipper.style.borderWidth = snipperBorderWidth + 'px'
    this._snipper.style.transform = `matrix(1,0,0,1,${-snipperBorderWidth},${-snipperBorderWidth})`
    this._container.append(this._snipper)
    this._resizer = document.createElement('div')
    this._resizer.classList.add('screenshot-snipper-resizer')
    this._snipper.append(this._resizer)
  }

  _initSnipperEvent () {
    _addDragEvent({
      node: this._container,
      downCallback: () => {
        this._snipper.style.borderColor = 'rgba(0,0,0,0.6)'
        this._snipper.style.cursor = 'crosshair'
        this._destroyResizer()
        this._destroyDrawer()
        this._snipInfo = {}
      },
      moveCallback: ({ endPosition, startPosition }) => {
        const snipperBorderWidth = parseFloat(this._snipper.style.borderWidth)
        this._snipInfo = {
          width: Math.abs(endPosition.x - startPosition.x),
          height: Math.abs(endPosition.y - startPosition.y),
          left: Math.min(endPosition.x, startPosition.x) - this._container.offsetLeft,
          top: Math.min(endPosition.y, startPosition.y) - this._container.offsetTop
        }
        this._snipper.style.width = this._snipInfo.width + 'px'
        this._snipper.style.height = this._snipInfo.height + 'px'
        this._snipper.style.transform = `matrix(1,0,0,1,${
          this._snipInfo.left - snipperBorderWidth
        },${this._snipInfo.top - snipperBorderWidth})`
      },
      upCallback: () => {
        this._snipper.style.cursor = 'default'
        this._initResizer()
        let originLeft, originTop
        _addDragEvent({
          node: this._resizer,
          upNode: this._container,
          moveNode: this._container,
          last: true,
          downCallback: () => {
            this._destroyResizer()
            this._destroyDrawer()
            originLeft = this._snipInfo.left
            originTop = this._snipInfo.top
          },
          moveCallback: ({ endPosition, startPosition }) => {
            const snipperBorderWidth = parseFloat(this._snipper.style.borderWidth)
            const left = originLeft + endPosition.x - startPosition.x
            const top = originTop + endPosition.y - startPosition.y
            const containerStyle = window.getComputedStyle(this._container)
            const containerWidth = parseFloat(containerStyle.width)
            const containerHeight = parseFloat(containerStyle.height)
            this._snipInfo.left = left >= 0 ? (left + this._snipInfo.width <= containerWidth ? left : containerWidth - this._snipInfo.width) : 0
            this._snipInfo.top = top >= 0 ? (top + this._snipInfo.height <= containerHeight ? top : containerHeight - this._snipInfo.height) : 0
            this._snipper.style.transform = `matrix(1,0,0,1,${
              this._snipInfo.left - snipperBorderWidth
            },${this._snipInfo.top - snipperBorderWidth})`
          },
          upCallback: () => {
            this._initResizer()
          }
        })
      }
    })
  }

  _initResizer () {
    this._destroyResizer()
    const wrapper = document.createElement('div')
    wrapper.classList.add('screenshot-snipper-resizer-wrapper')
    for (const direction of ['top', 'topright', 'right', 'bottomright', 'bottom', 'bottomleft', 'left', 'topleft']) {
      const resizer = document.createElement('div')
      resizer.classList.add('screenshot-snipper-resizer-item')
      resizer.classList.add(`screenshot-snipper-resizer-${direction}`)
      wrapper.append(resizer)
    }
    this._resizer.append(wrapper)
  }

  _destroyResizer () {
    _clearDom(this._resizer)
  }

  _initDrawer () {
    this._destroyDrawer()
    this._drawer = document.createElement('div')
    this._drawer.classList.add('screenshot-drawer')
    this._drawer.style.width = this._snipInfo.width + 'px'
    this._drawer.style.height = this._snipInfo.height + 'px'
    this._drawer.style.transform = `matrix(1,0,0,1,${this._snipInfo.x},${this._snipInfo.y})`
    this._container.append(this._drawer)
    this._initDrawerEvent()
  }

  _destroyDrawer () {
    if (this._drawer) {
      this._drawer.remove()
      delete this._drawer
    }
  }

  _initDrawerEvent () {
    this._drawer.addEventListener('mousedown', function (e) {
      e.preventDefault()
      e.stopPropagation()
    })
  }
}

/**
 * 清空节点
 * @param {HTMLElement} node
 */
function _clearDom (node) {
  if (!(node instanceof window.HTMLElement)) {
    throw new Error('node must be HTMLElement')
  }
  while (node.firstChild) {
    node.removeChild(node.lastChild)
  }
}

function _addDragEvent ({ node, moveNode, upNode, moveCallback = () => {}, downCallback = () => {}, upCallback = () => {}, last = false } = {}) {
  if (!(node instanceof window.HTMLElement)) {
    throw new Error('node must be HTMLElement')
  }

  let startPosition
  upNode = upNode || node
  moveNode = moveNode || node

  node.addEventListener('click', () => {})
  node.addEventListener('mousedown', _handleMouseDown)
  upNode.addEventListener('mouseup', _handleMouseUp)

  function _handleMouseDown (e) {
    e.stopPropagation()
    e.preventDefault()
    startPosition = {
      x: e.clientX,
      y: e.clientY
    }
    moveNode.addEventListener('mousemove', _handleMouseMove)
    downCallback({ startPosition })
  }

  function _handleMouseMove (e) {
    e.stopPropagation()
    e.preventDefault()
    moveCallback({
      startPosition,
      endPosition: {
        x: e.clientX,
        y: e.clientY
      }
    })
  }

  function _handleMouseUp (e) {
    e.stopPropagation()
    e.preventDefault()
    if (!startPosition) {
      return
    }
    moveNode.removeEventListener('mousemove', _handleMouseMove)
    if (!last) {
      node.removeEventListener('mousedown', _handleMouseDown)
      upNode.removeEventListener('mouseup', _handleMouseUp)
    }
    upCallback({
      startPosition,
      endPosition: {
        x: e.clientX,
        y: e.clientY
      }
    })
    startPosition = null
  }

  function stop () {
    last = false
    moveNode.removeEventListener('mousemove', _handleMouseMove)
    if (!last) {
      node.removeEventListener('mousedown', _handleMouseDown)
      upNode.removeEventListener('mouseup', _handleMouseUp)
    }
    startPosition = null
  }

  return {
    stop
  }
}
